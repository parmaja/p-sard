unit sardObjects;
{**
 *  This file is part of the "SARD"
 *
 * @license   The MIT License (MIT)
 *            Included in this distribution
 * @author    Zaher Dirkey 
 *}

{**
  Unit: Objects of run time generated by the scanner and raise in the memory until you free it,
  you can run it multiple time, also in the seperated thread

  The main object is TsoMain

  Object have Execute and Operate
  Some objects (like Section) have a Block, and some have one Statment
  Block have Statements
    Statement: haves Node
      Node: Object

  Declare: is define how to call that object, it have Defines and link to the object to execute and call
      Declare is a object of Caluse that call external (or internal) object, until now this object freed by declare and it is wrong :(

  Stack: have data for run time execute, you cant share value between thread or multiple execute for the main object
    So Stack have Local Variables, Shadow of object
  Shadow: it is mirror of object but have extra data about it that we can not save it in the original object,
    it is useful for multiexecute.

*}

{
  Blocks
    Statements
      Statement
        Node
        Node
      Statement
        Node
        Node
}

{$IFDEF FPC}
{$mode delphi}
{$WARN 5024 off : Parameter "$1" not used}
{$ENDIF}
{$H+}{$M+}

{
  Prefix guid:
    srd: global classes inherited from sard
    run: Runtime classes
    so: Sard objects, that created when compile the source
    op: Operators objects
}

{TODO:
  TtpType:    Type like integer, float, string, color or datetime, it is global, and limited

  TsoArray:   From the name, object have another objects, a list of objectd without execute it,
              it is save the result of statment come from the parser

* TsrdShadow: This object shadow of another object, he resposible of the memory storage like a varible
              When need to execute an object it will done by this shadow and insure it is exist before run
              Also we can make muliple shadow of one object when creating link to it, i mean creating another object based on first one
              Also it is made for dynamic scoping, we can access the value in it instead of local variable

  TsrdAddons: It have any kind of addon, parsing, preprocessor, or debugger

  TmdModifier: It is like operator but with one side can be in the context before the identifier like + !x %x $x

}
interface

uses
  Classes, SysUtils,
  sardClasses, sardParsers;

const
  sSardVersion = '0.01';
  iSardVersion = 001;

type
  TNode = class;
  TDefines = class;
  TRunData = class;
  TRunEnv = class;

  TDebugInfo = class(TSardObject)
  end;

  { TStatement }

  TStatement = class(TSardObjects<TNode>)
  private
    FDebugInfo: TDebugInfo;
    FParent: TNode;
  protected
    procedure ExportWrite(Writer: TSourceWriter; LastOne: Boolean; Level: Integer); virtual;
  public
    constructor Create(AParent: TNode);
    procedure Add(AObject: TNode);
    procedure Execute(Data: TRunData; Env: TRunEnv);
    property Parent: TNode read FParent;
    property DebugInfo: TDebugInfo read FDebugInfo; //<-- Null until we compiled it with Debug Info
  end;

  { TStatements }

  TStatements = class(TSardObjects<TStatement>)
  private
    FParent: TNode;
    procedure ExportWrite(Writer: TSourceWriter; LastOne: Boolean; Level: Integer); virtual;
  public
    constructor Create(AParent: TNode); virtual;
    function Add: TStatement;
    procedure Propose;
    function Execute(Data: TRunData; Env: TRunEnv): Boolean;
    property Parent: TNode read FParent;
  end;

  { TNode }

  TNode = class abstract(TSardNamedObject)
  private
    FID: Integer;
    FInternal: Boolean;
    FParent: TNode;
    //FRefCount: Integer;
    function GetAsBool: Bool;
    function GetAsInteger: Integer;
    function GetAsNumber: Number;
    function GetAsText: Text;
    procedure SetParent(AValue: TNode);
  protected
    procedure SetName(const AValue: string); override;
  public
    function ToBool(out outValue: Boolean): Boolean; virtual;
    function ToText(out outValue: Text): Boolean; virtual;
    function ToNumber(out outValue: Number): Boolean; virtual;
    function ToInteger(out outValue: Integer): Boolean; virtual;

    property AsBool: Bool read GetAsBool;
    property AsText: Text read GetAsText;
    property AsNumber: Number read GetAsNumber;
    property AsInteger: Integer read GetAsInteger;

    procedure Assign(AFromObject: TNode); virtual;
    function Clone(WithValues: Boolean = True): TNode;
  protected
    function DoOperate(AObject: TNode): Boolean; virtual;
    procedure DoExecute(Data: TRunData; Env: TRunEnv; var Done: Boolean); virtual; abstract;
    procedure BeforeExecute(Data: TRunData; Env: TRunEnv); virtual;
    procedure AfterExecute(Data: TRunData; Env: TRunEnv); virtual;
    procedure ExportWrite(Writer: TSourceWriter; LastOne: Boolean; Level: Integer); override;
  public
    constructor Create; overload; virtual;
    constructor CreateInternal;
    function Operate(AObject: TNode): Boolean;
    function Execute(Data: TRunData; Env: TRunEnv; Defines: TDefines = nil; Arguments: TStatements = nil; Blocks: TStatements = nil): Boolean;
    property Parent: TNode read FParent write SetParent;
    property ID: Integer read FID;
    property Internal: Boolean read FInternal; //registered inside
  end;

  TNodeClass = class of TNode;

  {TRefObject = class(TSardObject)
  end;}

  //f(x: integer, y: integer){
  //->  x: integer, y: integer
  { TDefine }

  TDefine = class(TSardNamedObject)
  private
    FDefType: string;
  public
    constructor Create(ADefName: string; ADefType: string);
    property DefType:string read FDefType write FDefType;
  end;

  { TDefineItems }

  TDefineItems = class(TSardNamedObjects<TDefine>)
  public
    procedure Add(ADefName: string; ADefType: string);
  end;

  { TDefines }

  TDefines = class(TSardObject)
  private
    FParameters: TDefineItems;
    FBlock: TDefineItems;
  public
    constructor Create;
    destructor Destroy; override;
    procedure Execute(Data: TRunData; Env: TRunEnv; Arguments: TStatements = nil);
    property Parameters: TDefineItems read FParameters;
    property Block: TDefineItems read FBlock;
  end;

  { TDeclare_Node }

  TDeclare_Node = class(TNode)
  private
    FDefines: TDefines;
  public
    //executeObject will execute in a context of statement if it is not null,
    ExecuteObject: TNode;
    ResultType: string;
    procedure Created; override;
    destructor Destroy; override;
    procedure DoExecute(Data: TRunData; Env: TRunEnv; var Done: Boolean); override;
    property Defines: TDefines read FDefines;
  end;

  { TEnclose_Node }
  // 10 + ( x + 10)
  //-> ( x + 10)
  TEnclose_Node = class(TNode)
  private
    FStatement: TStatement;
  protected
    procedure BeforeExecute(Data: TRunData; Env: TRunEnv); override;
    procedure AfterExecute(Data: TRunData; Env: TRunEnv); override;
    procedure DoExecute(Data: TRunData; Env: TRunEnv; var Done: Boolean); override;
    procedure ExportWrite(Writer: TSourceWriter; LastOne: Boolean; Level: Integer); override;
  public
    procedure Created; override;
    destructor Destroy; override;
    property Statement: TStatement read FStatement;
  end;

  { TStatements_Node }

  TStatements_Node = class(TNode)
  private
    FStatements: TStatements;
  protected
    procedure DoExecute(Data: TRunData; Env: TRunEnv; var Done: Boolean); override;
    procedure ExportWrite(Writer: TSourceWriter; LastOne: Boolean; Level: Integer); override;
  public
    procedure Created; override;
    destructor Destroy; override;
    property Statements: TStatements read FStatements;
  end;

  { TBlock_Node }

  TBlock_Node = class(TStatements_Node)
  private
  protected
    procedure BeforeExecute(Data: TRunData; Env: TRunEnv); override;
    procedure AfterExecute(Data: TRunData; Env: TRunEnv); override;
    procedure ExportWrite(Writer: TSourceWriter; LastOne: Boolean; Level: Integer); override;
  public
    procedure Created; override;
    destructor Destroy; override;
    function DeclareObject(AObject: TNode): TDeclare_Node;
  end;

  { TMain_Node }

  TMain_Node = class(TBlock_Node)
  public
    procedure ExportWrite(Writer: TSourceWriter; LastOne: Boolean; Level: Integer); override;
  end;

  { TConst_Node }

  TOperator_Node = class abstract(TNode)
  private
  protected
    procedure DoExecute(Data: TRunData; Env: TRunEnv; var Done: Boolean); override;
  public
  end;


  TAdd_Operator = class(TOperator_Node)
  protected
    procedure DoExecute(Data: TRunData; Env: TRunEnv; var Done: Boolean); override;
  public
  end;

  { TConst_Node }

  TConst_Node = class(TNode)
  private
  protected
    procedure DoExecute(Data: TRunData; Env: TRunEnv; var Done: Boolean); override;
  public
  end;

//*-------------------------------*/
//*       Const Objects
//*-------------------------------*/

  TNone_Node = class(TConst_Node)
    //Do operator
    //Convert to 0 or ''
  end;

  { TComment_Node }

  TComment_Node = class(TNode)
  protected
    procedure DoExecute(Data: TRunData; Env: TRunEnv; var Done: Boolean); override;
  public
    Value: string;
  end;

  { TPreprocessor_Node }

  TPreprocessor_Node = class(TNode) //TODO
  protected
    procedure DoExecute(Data: TRunData; Env: TRunEnv; var Done: Boolean); override;
  public
  end;

  TNumber_Node = class abstract(TConst_Node)
  end;

  { TInteger_Node }

  TInteger_Node = class(TNumber_Node)
  protected
    procedure ExportWrite(Writer: TSourceWriter; LastOne: Boolean; Level: Integer); override;
  public
    Value: Integer;
    constructor Create(AValue: Integer); overload;
    procedure Assign(AFromObject: TNode); override;
    function DoOperate(AObject: TNode): Boolean; override;
    function ToText(out outValue: Text): Boolean; override;
    function ToNumber(out outValue: Number): Boolean; override;
    function ToBool(out outValue: Boolean): Boolean; override;
    function ToInteger(out outValue: Integer): Boolean; override;
  end;

  { TReal_Node }

  TReal_Node = class(TNumber_Node)
  public
    Value: Double;
    constructor Create(AValue: Number); overload;
    procedure Assign(AFromObject: TNode); override;
    function DoOperate(AObject: TNode): Boolean; override;
    function ToText(out outValue: Text): Boolean; override;
    function ToNumber(out outValue: Number): Boolean; override;
    function ToBool(out outValue: Boolean): Boolean; override;
    function ToInteger(out outValue: Integer): Boolean; override;
  end;

  { TBool_Node }

  TBool_Node = class(TNumber_Node)
  public
    Value: Bool;
    constructor Create(AValue: Bool); overload;
    procedure Assign(AFromObject: TNode); override;
    function DoOperate(AObject: TNode): Boolean; override;
    function ToText(out outValue: Text): Boolean; override;
    function ToNumber(out outValue: Number): Boolean; override;
    function ToBool(out outValue: Boolean): Boolean; override;
    function ToInteger(out outValue: Integer): Boolean; override;
  end;

  { TDate_Node }  //TODO

  {TDate_Node = class(TNumber_Node)
  public
    Value: TDateTime;
    constructor Create(AValue: TDateTime); overload;
    procedure Assign(AFromObject: TNode); override;
    function DoOperate(AObject: TNode): Boolean; override;
    function ToText(out outValue: Text): Boolean;
    function ToNumber(out outValue: Number): Boolean;
    function ToBool(out outValue: Boolean): Boolean;
    function ToInteger(out outValue: Integer): Boolean;
  end;}

  { TText_Node }

  TText_Node = class(TConst_Node)
  public
    Value: string;
    constructor Create(AValue: string); overload;
    procedure Assign(AFromObject: TNode); override;
    function DoOperate(AObject: TNode): Boolean; override;
    function ToText(out outValue: Text): Boolean; override;
    function ToNumber(out outValue: Number): Boolean; override;
    function ToBool(out outValue: Boolean): Boolean; override;
    function ToInteger(out outValue: Integer): Boolean; override;
  end;

  { TInstance_Node }

  TInstance_Node = class(TNode)
  private
    FArguments: TStatements;
  protected
    procedure ExportWrite(Writer: TSourceWriter; LastOne: Boolean; Level: Integer); override;
  public
    procedure Created; override;
    destructor Destroy; override;
    procedure DoExecute(Data: TRunData; Env: TRunEnv; var Done: Boolean); override;
    property Arguments: TStatements read FArguments;
  end;

  { TAssign_Node }

  TAssign_Node = class(TNode)
  public
    constructor Create(AName: string = ''); overload;
    procedure DoExecute(Data: TRunData; Env: TRunEnv; var Done: Boolean); override;
    procedure ExportWrite(Writer: TSourceWriter; LastOne: Boolean; Level: Integer); override;
  end;

{
  *   Declare object to take it ref into variable
  *   used by Declare_Node
  //Is that a Scope!!!, idk!
}

{*
  Variables
*}

  TRunVarKind = (rkLocal, rkArgument);
  TRunVarKinds = set of TRunVarKind;

  { TSardRunValue }

  { TRunValue }

  TRunValue = class(TSardNamedObject)
  private
    FValue: TNode; //RefObject maybe IObject_Node
    FRunKind: TRunVarKinds;
    procedure SetValue(AValue: TNode);
  public
    constructor Create; overload;
    destructor Destroy; override;
    constructor Create(AName: string; ARunKind: TRunVarKinds); overload;
    procedure Clear;
    property RunKind: TRunVarKinds read FRunKind;
    property Value: TNode read FValue write SetValue;
  end;

  { TRunVariables }

  TRunVariables = class(TSardNamedObjects<TRunValue>)
  public
    function Register(AName: string; ARunKind: TRunVarKinds): TRunValue;
  end;

  { TRunResult }

  TRunResult = class(TSardObject)
  private
  public
    Result: TRunValue;
    constructor Create;
    destructor Destroy; override;
  end;

  { TRunResults }

  TRunResults = class(TSardStack<TRunResult>)
  public
    procedure Push; overload;
  end;

  { TRunData }

  TRunData = class(TSardObjects<TRunData>)
  private
    FAnObject: TDeclare_Node;
    FName: string;
    FParent: TRunData;
  public
    constructor Create(AParent: TRunData);

    function Find(const AName: string): TRunData;
    function FindObject(AObject: TNode): TRunData;
    function Declare(AObject: TDeclare_Node): TRunData;
    function FindDeclare(AName: string): TRunData;

    function Execute(Env: TRunEnv; Arguments: TStatements = nil; Blocks: TStatements = nil): Boolean;

    property Name: string read FName;
    property AnObject: TDeclare_Node read FAnObject;
    property Parent: TRunData read FParent;
  end;

{
  *  Local is stack of flow control
  *  Not a scope
  *
}

  { TRunStackItem }

  TRunStackItem = class(TSardObject)
  public
    Variables: TRunVariables;
    constructor Create;
    destructor Destroy; override;
  end;

  { TRunStack }

  TRunStack = Class(TSardStack<TRunStackItem>)
  public
    procedure Push; overload;
  end;

  { TRunEnv }

  TRunEnv = class(TSardObject)
  private
    FResults: TRunResults;
    FRoot: TRunData;
    FStack: TRunStack;
  public
    constructor Create;
    destructor Destroy; override;

    property Results: TRunResults read FResults;
    property Stack: TRunStack read FStack;
    property Root: TRunData read FRoot;
  end;

  { TSardOperator }

  TSardOperator = class(TSardNamedObject)
  public
    Title: string;
    Description: string;
  end;


  { TOpNone }

  TOpNone = class(TSardOperator)
  public
    constructor Create;
  end;

  { TOpAnd }

  TOpAnd = class(TSardOperator)
  public
    constructor Create;
  end;

  { TOpOr }

  TOpOr = class(TSardOperator)
  public
    constructor Create;
  end;

  { TOpPlus }

  TOpPlus = class(TSardOperator)
  public
    constructor Create;
  end;

  { TOpSub }

  TOpSub = class(TSardOperator)
  public
    constructor Create;
  end;

  { TOpMultiply }

  TOpMultiply = class(TSardOperator)
  public
    constructor Create;
  end;

  { TOpDivide }

  TOpDivide = class(TSardOperator)
  public
    constructor Create;
  end;

  { TOpPower }

  TOpPower = class(TSardOperator)
  public
    constructor Create;
  end;

  { TOpGreater }

  TOpGreater = class(TSardOperator)
  public
    constructor Create;
  end;

  { TOpLesser }

  TOpLesser = class(TSardOperator)
  public
    constructor Create;
  end;

  { TOpEqual }

  TOpEqual = class(TSardOperator)
  public
    constructor Create;
  end;

  { TOpNotEqual }

  TOpNotEqual = class(TSardOperator)
  public
    constructor Create;
  end;

  { TOpNot }

  TOpNot = class(TSardOperator)
  public
    constructor Create;
  end;

implementation

{ TMain_Node }

procedure TMain_Node.ExportWrite(Writer: TSourceWriter; LastOne: Boolean; Level: Integer);
begin
  inherited;
end;

{ TRunStack }

procedure TRunStack.Push;
begin
  inherited Push(TRunStackItem.Create);
end;

{ TRunResults }

procedure TRunResults.Push;
begin
  inherited Push(TRunResult.Create);
end;

{ TRunEnv }

constructor TRunEnv.Create;
begin
  inherited Create;
  FResults := TRunResults.Create(True);
  FRoot := TRunData.Create(nil);
  FStack := TRunStack.Create(False); //TODO check if own (nop)
end;

destructor TRunEnv.Destroy;
begin
  FreeAndNil(FResults);
  FreeAndNil(FRoot);
  FreeAndNil(FStack);
  inherited;
end;

{ TRunStackItem }

constructor TRunStackItem.Create;
begin
  inherited;
  Variables := TRunVariables.Create;
end;

destructor TRunStackItem.Destroy;
begin
  FreeAndNil(Variables);
  inherited;
end;

{ TDeclare_Node }

procedure TDeclare_Node.Created;
begin
  inherited;
  FDefines := TDefines.Create;
end;

destructor TDeclare_Node.Destroy;
begin
  FreeAndNil(FDefines);
  inherited;
end;

procedure TDeclare_Node.DoExecute(Data: TRunData; Env: TRunEnv; var Done: Boolean);
begin
  Data.Declare(Self);
end;

{ TRunData }

constructor TRunData.Create(AParent: TRunData);
begin
  inherited Create;
  FParent := AParent;
end;

function TRunData.Find(const AName: string): TRunData;
var
  i: Integer;
begin
  Result := nil;
  for i := 0 to Count - 1 do
  begin
    if SameText(Items[i].Name, AName) then
    begin
      Result := Items[i];
      break;
    end;
  end;
end;

function TRunData.FindObject(AObject: TNode): TRunData;
var
  i: Integer;
begin
  Result := nil;
  for i := 0 to Count - 1 do
  begin
    if Items[i].AnObject = AObject then
    begin
      Result := Items[i];
      break;
    end;
  end;
end;

function TRunData.Declare(AObject: TDeclare_Node): TRunData;
begin
  if AObject = nil then
    RaiseError('Can not register null in data');
  Result := FindObject(AObject);
  if Result = nil then
  begin
    Result := TRunData.Create(Self);
    Result.FName := AObject.Name;
    Result.FAnObject := AObject;
  end;
  Add(Result);//TODO BUG maybe into if
end;

function TRunData.FindDeclare(AName: string): TRunData;
begin
  Result := Find(AName);
  if (Result = nil) and (Parent <> nil) then
    Result := Parent.FindDeclare(AName);
end;

function TRunData.Execute(Env: TRunEnv; Arguments: TStatements; Blocks: TStatements): Boolean;
begin
  if AnObject = nil then
    RaiseError('Object of declaration is not set!')
  else if AnObject.ExecuteObject = nil then
    RaiseError('ExecuteObject of declaration is not set!');
  Result := AnObject.ExecuteObject.Execute(Self, Env, AnObject.Defines, Arguments, Blocks);
end;

{ TRunResult }

constructor TRunResult.Create;
begin
  inherited Create;
  Result := TRunValue.Create;
end;

destructor TRunResult.Destroy;
begin
  FreeAndNil(Result);
  inherited;
end;

{ TRunValue }

procedure TRunValue.SetValue(AValue: TNode);
begin
  if FValue = AValue then
    Exit;
  FValue :=AValue;
end;

constructor TRunValue.Create;
begin
  inherited Create;
end;

destructor TRunValue.Destroy;
begin
  FreeAndNil(FValue);
  inherited;
end;

constructor TRunValue.Create(AName: string; ARunKind: TRunVarKinds);
begin
  inherited Create;
  Name := AName;
  FRunKind := ARunKind;
end;

procedure TRunValue.Clear;
begin
  Value := nil;
end;

{ TRunVariables }

function TRunVariables.Register(AName: string; ARunKind: TRunVarKinds): TRunValue;
begin
  Result := Find(AName);
  if Result = nil then
  begin
    Result := TRunValue.Create(AName, ARunKind);
    inherited Add(Result);
  end;
end;

{ TDefines }

constructor TDefines.Create;
begin
  inherited Create;
  FParameters := TDefineItems.Create;
  FBlock := TDefineItems.Create;
end;

destructor TDefines.Destroy;
begin
  FreeAndNil(FParameters);
  FreeAndNil(FBlock);
  inherited Destroy;
end;

{ TDefineItems }

procedure TDefineItems.Add(ADefName: string; ADefType: string);
begin
  inherited Add(TDefine.Create(ADefName, ADefType));
end;

{ TDefine }

constructor TDefine.Create(ADefName: string; ADefType: string);
begin
  inherited Create;
  Name := ADefName;
  FDefType := ADefType;
end;

procedure TDefines.Execute(Data: TRunData; Env: TRunEnv; Arguments: TStatements);
var
  i: Integer;
  p: TDefine;
  v: TRunValue;
begin
  if Arguments <> nil then
  begin //TODO we need to check if it is a block?
    i := 0;
    while i < Parameters.Count do
    begin
      Env.Results.Push;
      if i < Arguments.Count then
      begin
        Arguments[i].Execute(Data, Env);

        p := Parameters[i];
        v := Env.Stack.Current.Variables.Register(p.name, [rkLocal, rkArgument]); //TODO but must find it locally
        v.Value := Env.Results.Current.Result.Value;
      end;
      Env.Results.Pop;
      Inc(i);
    end;
  end;
end;

{ TStatements }

constructor TStatements.Create(AParent: TNode);
begin
  inherited Create;
  FParent := AParent;
end;

function TStatements.Add: TStatement;
begin
  Result := TStatement.Create(Parent);
  inherited Add(Result);
end;

procedure TStatements.Propose;
begin
  if Count = 0 then
    Add;
end;

function TStatements.Execute(Data: TRunData; Env: TRunEnv): Boolean;
var
  itm: TStatement;
begin
  if Count = 0 then
    Result := False
  else
  begin
    for itm in Self do
    begin
      //* each statment have a result
      Env.Results.Push;
      itm.Execute(Data, Env);
      Env.Results.Pop;
      //* if the current statement assigned to parent or variable result "Reference" here have this object, or we will throw the result
    end;
    Result := True;
  end;
end;

procedure TStatements.ExportWrite(Writer: TSourceWriter; LastOne: Boolean; Level: Integer);
var
  itm: TStatement;
begin
  inherited;
  for itm in Self do
  begin
    itm.ExportWrite(Writer, LastOne, Level + 1);
  end;
end;

{ TStatement }

procedure TStatement.Add(AObject: TNode);
begin
  if (AObject = nil) then
    RaiseError('You can not add nil object!');
  if (AObject.Parent <> nil) then
    RaiseError('You can not add object to another parent!');
  AObject.FParent := Parent;
  inherited Add(AObject);
end;

procedure TStatement.Execute(Data: TRunData; Env: TRunEnv);
var
  itm: TNode;
begin
  //https://en.wikipedia.org/wiki/Shunting-yard_algorithm
  //:= "Result is " + 10 + 10 ;
  for itm in Self do
  begin
    itm.Execute(Data, Env);
  end;
end;

procedure TStatement.ExportWrite(Writer: TSourceWriter; LastOne: Boolean; Level: Integer);
var
  itm: TNode;
begin
  inherited;
  //https://en.wikipedia.org/wiki/Shunting-yard_algorithm
  //:= "Result is " + 10 + 10 ;
  for itm in Self do
  begin
    itm.ExportWrite(Writer, LastOne, Level + 1);
  end;
end;

constructor TStatement.Create(AParent: TNode);
begin
  inherited Create;
  FParent := AParent;
end;

{ TNode }

function TNode.GetAsBool: Bool;
begin
  if not ToBool(Result) then
    Result := false;
end;

function TNode.GetAsInteger: Integer;
begin
  if not ToInteger(Result) then
    Result := 0;
end;

function TNode.GetAsNumber: Number;
begin
  if not ToNumber(Result) then
    Result := 0;
end;

function TNode.GetAsText: Text;
begin
  if not ToText(Result) then
    Result := '';
end;

procedure TNode.SetParent(AValue: TNode);
begin
  if (FParent <> nil) then
    RaiseError('Already have a parent');
  FParent := AValue;
end;

procedure TNode.SetName(const AValue: string);
begin
  if Name <> '' then
    RaiseError('Already Named!');
  inherited;
end;

{constructor TNode.Create(AParent: TNode; AName: string);
begin
  inherited Create;
  Name := AName;
  FParent := AParent;
end;}

function TNode.Operate(AObject: TNode): Boolean;
begin
   Result := DoOperate(AObject);
end;

function TNode.Execute(Data: TRunData; Env: TRunEnv; Defines: TDefines; Arguments: TStatements; Blocks: TStatements): Boolean;
begin
  Result := False;
  BeforeExecute(Data, Env);
  if (Defines <> nil) then
    Defines.Execute(Data, Env, Arguments);
  DoExecute(Data, Env, Result);
  AfterExecute(Data, Env);
end;

function TNode.ToBool(out outValue: Boolean): Boolean;
begin
  Result := False;
end;

function TNode.ToText(out outValue: Text): Boolean;
begin
  Result := False;
end;

function TNode.ToNumber(out outValue: Number): Boolean;
begin
  Result := False;
end;

function TNode.ToInteger(out outValue: Integer): Boolean;
begin
  Result := False;
end;

procedure TNode.Assign(AFromObject: TNode);
begin
  //Nothing
end;

function TNode.Clone(WithValues: Boolean): TNode;
begin
  //TODO, here we want to check if subclass have a default ctor
  Result := TNodeClass(ClassType).Create;
  Result.FParent := Parent;
  if WithValues then
    Result.Assign(Self);
end;

function TNode.DoOperate(AObject: TNode): Boolean;
begin
  Result := False;
end;

procedure TNode.BeforeExecute(Data: TRunData; Env: TRunEnv);
begin
  if Data = nil then
    RaiseError('Data is needed!');
end;

procedure TNode.AfterExecute(Data: TRunData; Env: TRunEnv);
begin

end;

var LastID: Integer = 0;

constructor TNode.Create;
begin
  inherited Create;
  Inc(LastID);
  FID := LastID;
end;

constructor TNode.CreateInternal;
begin
  Create;
  FInternal := True;
end;

procedure TNode.ExportWrite(Writer: TSourceWriter; LastOne: Boolean; Level: Integer);
begin
  inherited;
end;

{ TAssign_Node }

constructor TAssign_Node.Create(AName: string);
begin
  inherited Create;
  Name := AName;
end;

procedure TAssign_Node.DoExecute(Data: TRunData; Env: TRunEnv; var Done: Boolean);
var
  v: TRunValue;
begin
  //* if not have a name, assign it to parent result
  Done := true;
  if (Name = '') then
    Env.Results.Current.Result := Env.Results.Parent.Result
  else
  begin
    //Ok let is declare it locally
    v := Env.Stack.Current.Variables.Register(Name, [rkLocal]);
    if (v = nil) then
      RaiseError('Variable not found!');
    Env.Results.Current.Result := v;
  end;
end;

procedure TAssign_Node.ExportWrite(Writer: TSourceWriter; LastOne: Boolean; Level: Integer);
begin
  inherited;
  Writer.Add(Name + ' := ');
end;

{ TInstance_Node }

procedure TInstance_Node.Created;
begin
  inherited;
  FArguments := TStatements.Create(Self);
end;

destructor TInstance_Node.Destroy;
begin
  FreeAndNil(FArguments);
  inherited;
end;

procedure TInstance_Node.DoExecute(Data: TRunData; Env: TRunEnv; var Done: Boolean);
var
  d: TRunData;
  v: TRunValue;
begin
  d := Data.FindDeclare(name);
  if d <> nil then
    Done := d.Execute(Env, Arguments, nil)
  else
  begin
    v := Env.Stack.Current.Variables.Find(Name);
    if (v = nil) then
        RaiseError('Can not find a variable: ' + Name);
    if (v.value = nil) then
        RaiseError('Variable object is null: ' + v.Name);
    Done := v.Value.Execute(Data, Env);
  end;
end;

procedure TInstance_Node.ExportWrite(Writer: TSourceWriter; LastOne: Boolean; Level: Integer);
begin
  inherited;
end;

{ TText_Node }

constructor TText_Node.Create(AValue: string);
begin
  inherited Create;
  Value := AValue;
end;

procedure TText_Node.Assign(AFromObject: TNode);
begin
  inherited;
  Value := AFromObject.AsTExt;
end;

function TText_Node.DoOperate(AObject: TNode): Boolean;
begin
  Result :=inherited DoOperate(AObject);
end;

function TText_Node.ToText(out outValue: Text): Boolean;
begin
  outValue := Value;
  Result := true;
end;

function TText_Node.ToNumber(out outValue: Number): Boolean;
begin
  outValue := StrToFloatDef(Value, 0);
  Result := true;
end;

function TText_Node.ToBool(out outValue: Boolean): Boolean;
begin
  outValue := StrToBoolDef(Value, False);
  Result := true;
end;

function TText_Node.ToInteger(out outValue: Integer): Boolean;
begin
  outValue := StrToIntDef(Value, 0);
  Result := true;
end;

{ TBool_Node }

constructor TBool_Node.Create(AValue: Bool);
begin
  inherited Create;
  Value := AValue;
end;

procedure TBool_Node.Assign(AFromObject: TNode);
begin
  inherited;
  Value := AFromObject.AsBool;
end;

function TBool_Node.DoOperate(AObject: TNode): Boolean;
begin
  Result := inherited DoOperate(AObject);
(*  if AOperator.name = '+' then
      begin
          Value := Value and AObject.AsBool;
          Result := true;
      end
  else if AOperator.name = '-' then
      begin
          Value := Value and not AObject.AsBool; //xor //LOL
          Result := true;
      end
  else if AOperator.name = '*' then
      begin
          Value := Value or AObject.AsBool;
          Result := True;
      end
{ else if AOperator.name = '/' then
      begin
          Value := Value / AObject.AsNumber;
          Result := True;
      end;}
      else
          Result := False;
*)
end;

function TBool_Node.ToText(out outValue: Text): Boolean;
begin
  outValue := BoolToStr(Value);
  Result := true;
end;

function TBool_Node.ToNumber(out outValue: Number): Boolean;
begin
  outValue := Ord(Value);
  Result := true;
end;

function TBool_Node.ToBool(out outValue: Boolean): Boolean;
begin
  outValue := Value;
  Result := true;
end;

function TBool_Node.ToInteger(out outValue: Integer): Boolean;
begin
  outValue := Ord(Value);
  Result := true;
end;

{ TReal_Node }

constructor TReal_Node.Create(AValue: Number);
begin
  inherited Create;
  Value := AValue;
end;

procedure TReal_Node.Assign(AFromObject: TNode);
begin
  inherited;
  Value := AFromObject.AsNumber;
end;

function TReal_Node.DoOperate(AObject: TNode): Boolean;
begin
  Result := inherited DoOperate(AObject);
(*  if AOperator.name = '+' then
      begin
          Value := Value + AObject.AsNumber;
          Result := true;
      end
  else if AOperator.name = '-' then
      begin
          Value := Value - AObject.AsNumber;
          Result := true;
      end
  else if AOperator.name = '*' then
      begin
          Value := Value * AObject.AsNumber;
          Result := True;
      end
  else if AOperator.name = '/' then
      begin
          Value := Value / AObject.AsNumber;
          Result := True;
      end
      else
          Result := False;
*)
end;

function TReal_Node.ToText(out outValue: Text): Boolean;
begin
  outValue := FloatToStr(Value);
  Result := true;
end;

function TReal_Node.ToNumber(out outValue: Number): Boolean;
begin
  outValue := Value;
  Result := true;
end;

function TReal_Node.ToBool(out outValue: Boolean): Boolean;
begin
  outValue := Value <> 0;
  Result := true;
end;

function TReal_Node.ToInteger(out outValue: Integer): Boolean;
begin
  outValue := Round(Value);
  Result := true;
end;

{ TInteger_Node }

procedure TInteger_Node.ExportWrite(Writer: TSourceWriter; LastOne: Boolean; Level: Integer);
begin
  inherited;
  Writer.Add(IntToStr(Value));
end;

constructor TInteger_Node.Create(AValue: Integer);
begin
  inherited Create;
  Value := AValue;
end;

procedure TInteger_Node.Assign(AFromObject: TNode);
begin
  inherited;
  Value := AFromObject.AsInteger;
end;

function TInteger_Node.DoOperate(AObject: TNode): Boolean;
begin
  Result := inherited DoOperate(AObject);
(*  if AOperator.name = '+' then
      begin
          Value := Value + AObject.asInteger;
          Result := true;
      end
  else if AOperator.name = '-' then
      begin
          Value := Value - AObject.AsInteger;
          Result := true;
      end
  else if AOperator.name =  '*' then
      begin
          Value := Value * AObject.AsInteger;
          Result := True;
      end
  else if AOperator.name = '/' then
      begin
          Value := Value div AObject.AsInteger;
          Result := True;
      end
      else
          Result := False;
*)
end;

function TInteger_Node.ToText(out outValue: Text): Boolean;
begin
  outValue := IntToStr(Value);
  Result := True;
end;

function TInteger_Node.ToNumber(out outValue: Number): Boolean;
begin
  outValue := Value;
  Result := True;
end;

function TInteger_Node.ToBool(out outValue: Boolean): Boolean;
begin
  outValue := Value <> 0;
  Result := True;
end;

function TInteger_Node.ToInteger(out outValue: Integer): Boolean;
begin
  outValue := Value;
  Result := True;
end;

{ TPreprocessor_Node }

procedure TPreprocessor_Node.DoExecute(Data: TRunData; Env: TRunEnv; var Done: Boolean);
begin
  //TODO execute external program and replace it with the result
  Done := True;
end;

{ TComment_Node }

procedure TComment_Node.DoExecute(Data: TRunData; Env: TRunEnv; var Done: Boolean);
begin
  //Guess what!, we will not to execute the comment ;)
  Done := True;
end;

{ TConst_Node }

procedure TConst_Node.DoExecute(Data: TRunData; Env: TRunEnv; var Done: Boolean);
begin
  if (Env.results.Current = nil) then
      RaiseError('There is no stack results!');
  if (Env.Results.Current.Result.Value = nil) then
  begin
      Env.Results.Current.Result.Value := Clone();
      Done := true;
  end
  else
  begin
      if (Env.Results.current.Result.Value = nil) then
        Env.Results.Current.Result.Value := Clone(False);
      Done := Env.Results.Current.Result.Value.Operate(Self);
  end;
end;

{ TBlock_Node }

procedure TBlock_Node.BeforeExecute(Data: TRunData; Env: TRunEnv);
begin
  Env.Stack.Push;
  inherited;
end;

procedure TBlock_Node.AfterExecute(Data: TRunData; Env: TRunEnv);
begin
  inherited;
  Env.Stack.Pop;
end;

procedure TBlock_Node.ExportWrite(Writer: TSourceWriter; LastOne: Boolean; Level: Integer);
begin
  inherited;
end;

procedure TBlock_Node.Created;
begin
  inherited;
end;

destructor TBlock_Node.Destroy;
begin
  inherited Destroy;
end;

function TBlock_Node.DeclareObject(AObject: TNode): TDeclare_Node;
begin
  with Statements.Add do
  begin
    Result := TDeclare_Node.Create;
    Result.Name := AObject.Name;
    AObject.Parent := Result;
    Result.ExecuteObject := AObject;
    Add(nil);
  end;
end;

{ TStatements_Node }

procedure TStatements_Node.DoExecute(Data: TRunData; Env: TRunEnv; var Done: Boolean);
var
  t: TRunResult;
begin
  {if (env.stack.current.data.object !is this)
      error("Can not execute block directly, data.object must set to this encloser");}
  Env.Results.Push; //<--here we can push a variable result or create temp result to drop it

  Statements.Execute(Data, Env);
  t := Env.Results.Pull;
  //I dont know what if there is an object there what we do???
(*
  * := 5 + { := 10 + 10 }
  * it return 25
  * here 20.execute with +
*)
  if (t.Result.Value <> nil) then
      t.Result.Value.Execute(Data, Env);
  Done := True;
end;

procedure TStatements_Node.ExportWrite(Writer: TSourceWriter; LastOne: Boolean; Level: Integer);
begin
  inherited;
  Statements.ExportWrite(Writer, LastOne, Level);
  Writer.Add(';');
  Writer.NewLine;
end;

procedure TStatements_Node.Created;
begin
  inherited;
  FStatements := TStatements.Create(Parent);
end;

destructor TStatements_Node.Destroy;
begin
  FreeAndNil(FStatements);
  inherited;
end;

{ TEnclose_Node }

procedure TEnclose_Node.BeforeExecute(Data: TRunData; Env: TRunEnv);
begin
  inherited;
  Env.Results.Push;
end;

procedure TEnclose_Node.AfterExecute(Data: TRunData; Env: TRunEnv);
var
  t: TRunResult;
begin
  inherited;
  t := Env.Results.Pull;
  if (t.Result.Value <> nil) then
    t.Result.Value.Execute(Data, Env);
end;

procedure TEnclose_Node.DoExecute(Data: TRunData; Env: TRunEnv; var Done: Boolean);
begin
  Statement.Execute(data, env);
  Done := true;
end;

procedure TEnclose_Node.Created;
begin
  inherited Created;
  FStatement := TStatement.Create(Parent);
end;

destructor TEnclose_Node.Destroy;
begin
  FreeAndNil(FStatement);
  inherited;
end;

procedure TEnclose_Node.ExportWrite(Writer: TSourceWriter; LastOne: Boolean; Level: Integer);
begin
  inherited;
  Writer.Add('(');
  FStatement.ExportWrite(Writer, LastOne, Level);
  Writer.Add(')');
end;

{******************************
          Operators
******************************}

{ TOpEqual }

constructor TOpEqual.Create;
begin
  Name := '=';
  Title := 'Equal';
  Description := '';
end;

{ TOpPower }

constructor TOpPower.Create;
begin
  Name := '^';
  Title := 'Power';
  Description := '';
end;

{ TOpGreater }

constructor TOpGreater.Create;
begin
  Name := '>';
  Title := 'Greater';
  Description := '';
end;

{ TOpLesser }

constructor TOpLesser.Create;
begin
  Name := '<';
  Title := 'Lesser';
  Description := '';
end;

{ TOpNotEqual }

constructor TOpNotEqual.Create;
begin
  Name := '<>';
  Title := 'NotEqual';
  Description := 'Check Equal';
end;

{ TOpNot }

constructor TOpNot.Create;
begin
  Name := '!';
  Title := 'not';
  Description := 'Not';
end;

{ TOpDivide }

constructor TOpDivide.Create;
begin
  Name := '/';
  Title := 'Divide';
  Description := 'Divide object on another object';
end;

{ TOpMultiply }

constructor TOpMultiply.Create;
begin
  Name := '*';
  Title := 'Multiply';
  Description := 'Multiply object with another object';
end;

{ TOpSub }

constructor TOpSub.Create;
begin
  Name := '-';
  Title := 'Minus';
  Description := 'Sub object from another object';
end;

{ TOpPlus }

constructor TOpPlus.Create;
begin
  Name := '+';
  Title := 'Plus';
  Description := 'Add object to another object';
end;

{ TOpOr }

constructor TOpOr.Create;
begin
  Name := '|';
  Title := 'Or';
  Description := '';
end;

{ TOpAnd }

constructor TOpAnd.Create;
begin
  Name := '&';
  Title := 'And';
  Description := '';
end;

{ TOpNone }

constructor TOpNone.Create;
begin
  Name := '';
  Title := 'None';
  Description := 'Nothing';
end;
{ TOperator_Node }

procedure TOperator_Node.DoExecute(Data: TRunData; Env: TRunEnv; var Done: Boolean);
begin
end;

{ TAdd_Operator }

procedure TAdd_Operator.DoExecute(Data: TRunData; Env: TRunEnv; var Done: Boolean);
begin
  inherited;
end;

end.
